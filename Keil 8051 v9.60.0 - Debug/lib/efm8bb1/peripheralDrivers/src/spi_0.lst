C51 COMPILER V9.60.0.0   SPI_0                                                             11/11/2022 12:14:21 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE SPI_0
OBJECT MODULE PLACED IN .\lib/efm8bb1/peripheralDrivers/src/spi_0.OBJ
COMPILER INVOKED BY: Z:\Applications\Simplicity Studio.app\Contents\Eclipse\developer\toolchains\keil_8051\9.60\BIN\C51.
                    -exe /Applications/Simplicity Studio.app/Contents/Eclipse/developer/sdks/8051/v4.2.4/Device/EFM8BB1/peripheral_driver/src
                    -/spi_0.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVEC
                    -TOR(0X0000) INTPROMOTE INCDIR(/Users/paul_leveque/Documents/10_Projets/EFM8BB1_PCA_Lib_8bitCenterPWM/inc;/Users/paul_lev
                    -eque/Documents/10_Projets/EFM8BB1_PCA_Lib_8bitCenterPWM/inc/config;/Users/paul_leveque/Documents/10_Projets/EFM8BB1_PCA_
                    -Lib_8bitCenterPWM/drivers;/Applications/Simplicity Studio.app/Contents/Eclipse/developer/sdks/8051/v4.2.4//Lib/efm8_asse
                    -rt;/Applications/Simplicity Studio.app/Contents/Eclipse/developer/sdks/8051/v4.2.4//Device/shared/si8051Base;/Applicatio
                    -ns/Simplicity Studio.app/Contents/Eclipse/developer/sdks/8051/v4.2.4//Device/EFM8BB1/inc;/Applications/Simplicity Studio
                    -.app/Contents/Eclipse/developer/sdks/8051/v4.2.4//kits/common/bsp;/Applications/Simplicity Studio.app/Contents/Eclipse/d
                    -eveloper/sdks/8051/v4.2.4//kits/EFM8BB1_LCK/config;/Applications/Simplicity Studio.app/Contents/Eclipse/developer/sdks/8
                    -051/v4.2.4//Device/EFM8BB1/peripheral_driver/inc) PRINT(.\lib/efm8bb1/peripheralDrivers/src/spi_0.lst) COND PAGEWIDTH(12
                    -0) PAGELENGTH(65) OBJECT(.\lib/efm8bb1/peripheralDrivers/src/spi_0.OBJ)

line level    source

   1          /******************************************************************************
   2           * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3           *
   4           * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5           *****************************************************************************/
   6          
   7          #include "efm8_config.h"
   8          #include "SI_EFM8BB1_Register_Enums.h"
   9          #include "spi_0.h"
  10          
  11          // Runtime API
  12          
  13          // Flag to indicate if driver should control Nss (chip select)
  14          static bool useNss  = false;
  15          
  16          // flag to indicate we are in master mode (else slave)
  17          static bool modeIsMaster = false;
  18          
  19          // flag to indicate that init vars (above) are valid.  If they are
  20          // not valid then a special one-time init will be called to set them
  21          static bool initIsValid = false;
  22          
  23          // ----------------------------------------------------------------------------
  24          // Initialize internal state variables.  This is used if init API is
  25          // not called.
  26          // ----------------------------------------------------------------------------
  27          static void SPI0_internalInit(void)
  28          {
  29   1        // figure out if we are master mode, and using 4-wire or not
  30   1        modeIsMaster = SPI0CFG & SPI0CFG_MSTEN__MASTER_ENABLED;
  31   1        useNss = SPI0CN0 & SPI0CN0_NSSMD__FMASK;
  32   1      
  33   1        // indicate that init has now been done
  34   1        initIsValid = true;
  35   1      }
  36          
  37          // ----------------------------------------------------------------------------
  38          // Write a byte if transmit buffer is not full.
  39          // ----------------------------------------------------------------------------
  40          bool SPI0_writeByte(uint8_t value)
  41          {
  42   1        bool ret = false;
  43   1        // check to see if transmit buffer is not full
  44   1        if (SPI0CN0_TXBMT)
  45   1        {
C51 COMPILER V9.60.0.0   SPI_0                                                             11/11/2022 12:14:21 PAGE 2   

  46   2          SPI0DAT = value;
  47   2          ret = true;
  48   2        }
  49   1        return ret;
  50   1      }
  51          
  52          // ----------------------------------------------------------------------------
  53          // Write a byte, waiting for transmit buffer to be empty
  54          // ----------------------------------------------------------------------------
  55          void SPI0_pollWriteByte(uint8_t value)
  56          {
  57   1        // wait for TX empty
  58   1        while (!SPI0CN0_TXBMT)
  59   1        {}
  60   1      
  61   1        SPI0DAT = value;
  62   1      }
  63          
  64          // ----------------------------------------------------------------------------
  65          // Perform a multi-byte transfer, waiting for each byte to complete.
  66          // ----------------------------------------------------------------------------
  67          uint8_t
  68          SPI0_pollTransfer(SI_VARIABLE_SEGMENT_POINTER(pTxBuffer, uint8_t,
  69                                                        EFM8PDL_SPI0_TX_SEGTYPE),
  70                            SI_VARIABLE_SEGMENT_POINTER(pRxBuffer, uint8_t,
  71                                                        EFM8PDL_SPI0_RX_SEGTYPE),
  72                            SPI0_TransferDirection_t dir,
  73                            uint8_t xferCount)
  74          {
  75   1        uint8_t txCount = xferCount;
  76   1        bool checkNss = false;
  77   1      
  78   1        // This function is not interrupt driven and if SPI interrupts are
  79   1        // enabled, it can cause interference.
  80   1        SPI0_disableInt();
  81   1      
  82   1        // make sure SPI is not already busy
  83   1        while (SPI0CFG & SPI0CFG_SPIBSY__BMASK)
  84   1        {}
  85   1      
  86   1        // Check to see if run-time mode variables have been set up
  87   1        if (!initIsValid)
  88   1        {
  89   2          SPI0_internalInit();
  90   2        }
  91   1      
  92   1        // Flush the RX buffer in case something is in there
  93   1        {
  94   2          uint8_t dummy = SPI0DAT;
  95   2        }
  96   1      
  97   1        // Clear the interrupt flag that is used to indicate transfer complete
  98   1        SPI0CN0_SPIF = 0;
  99   1      
 100   1        // assert NSS (if used)
 101   1        if (modeIsMaster && useNss)
 102   1        {
 103   2          SPI0CN0_NSSMD0 = 0;
 104   2        }
 105   1      
 106   1        // Wait in loop until the requested number of transfers are complete
 107   1        // Note: xferCount tracks the number of bytes received
 108   1        while (xferCount)
C51 COMPILER V9.60.0.0   SPI_0                                                             11/11/2022 12:14:21 PAGE 3   

 109   1        {
 110   2          // If the transmit buffer is empty and there are still bytes to
 111   2          // write, then write a byte out
 112   2          if (SPI0CN0_TXBMT && txCount)
 113   2          {
 114   3            // If user provided a write buffer then use that
 115   3            if (dir & SPI0_TRANSFER_TX)
 116   3            {
 117   4              SPI0DAT = *pTxBuffer;
 118   4              ++pTxBuffer;
 119   4            }
 120   3      
 121   3            // else user did not provide write buffer so just use zeroes
 122   3            else
 123   3            {
 124   4              SPI0DAT = 0;
 125   4            }
 126   3      
 127   3            --txCount;
 128   3          }
 129   2      
 130   2          // If the interrupt flag is set it means a transfer has completed
 131   2          // so read a byte
 132   2          if (SPI0CN0_SPIF)
 133   2          {
 134   3            SPI0CN0_SPIF = 0;
 135   3      
 136   3            // If user provided RX buffer, then read byte into buffer
 137   3            if (dir & SPI0_TRANSFER_RX)
 138   3            {
 139   4              *pRxBuffer = SPI0DAT;
 140   4              ++pRxBuffer;
 141   4            }
 142   3      
 143   3            // else there is no RX buffer so just throw away the incoming byte
 144   3            else
 145   3            {
 146   4              uint8_t dummy = SPI0DAT;
 147   4            }
 148   3      
 149   3            --xferCount;
 150   3          }
 151   2      
 152   2          // If we are in slave mode and 4-wire, then check to make sure
 153   2          // slave is selected.  If not it means the spi master stopped
 154   2          // the transfer.  Bust out of the polling loop so we dont hang
 155   2          // here forever.
 156   2          if (!modeIsMaster && useNss)
 157   2          {
 158   3            // wait for nss to be asserted the first time before we
 159   3            // start checking it
 160   3            if (!checkNss)
 161   3            {
 162   4              if ((SPI0CFG & SPI0CFG_SLVSEL__BMASK))
 163   4              {
 164   5                checkNss = true;
 165   5              }
 166   4            }
 167   3            else
 168   3            {
 169   4              if (!(SPI0CFG & SPI0CFG_SLVSEL__BMASK))
 170   4              {
 171   5                break;
C51 COMPILER V9.60.0.0   SPI_0                                                             11/11/2022 12:14:21 PAGE 4   

 172   5              }
 173   4            }
 174   3          }
 175   2        }
 176   1      
 177   1        // Transfer is done.  Deassert NSS (if used)
 178   1        if (modeIsMaster && useNss)
 179   1        {
 180   2          SPI0CN0_NSSMD0 = 1;
 181   2        }
 182   1      
 183   1        return xferCount;
 184   1      }
 185          
 186          // ----------------------------------------------------------------------------
 187          // Check if SPI is busy with a transfer in progress.
 188          // ----------------------------------------------------------------------------
 189          bool SPI0_isBusy(void)
 190          {
 191   1        uint8_t count = 0;
 192   1        bool ret = false;
 193   1      
 194   1        // the SPI busy bit can drop between bytes so you cant just poll
 195   1        // it to find out when all the bytes have been transferred.  Or sometimes
 196   1        // you will catch it not set, between bytes when it is really still
 197   1        // busy.  To make busy test useful, we need to know when it is done
 198   1        // with all bytes.  That is why there is a loop below.
 199   1      
 200   1        // Read it several times and if the bit is ever marked busy, then
 201   1        // return busy indication.
 202   1        for (count = 0; count < 3; count++)
 203   1        {
 204   2          if (SPI0CFG & SPI0CFG_SPIBSY__BMASK)
 205   2          {
 206   3            ret = true;
 207   3          }
 208   2        }
 209   1      
 210   1        // If it makes it through the loops above without find the busy bit
 211   1        // then it is not busy.
 212   1        return ret;
 213   1      }
 214          
 215          // ----------------------------------------------------------------------------
 216          // Initialize the SPI peripheral operating parameters
 217          // ----------------------------------------------------------------------------
 218          void SPI0_init(SPI0_ClockMode_t clockMode, bool isMasterMode, bool is4wire)
 219          {
 220   1        // Figure out if this driver controls NSS signal (chip select)
 221   1        modeIsMaster = isMasterMode;
 222   1        useNss = is4wire;
 223   1        initIsValid = true;
 224   1      
 225   1        // disable SPI before configuring
 226   1        SPI0CN0_SPIEN = 0;
 227   1      
 228   1        // Set up the clock mode (phase and polarity), and the
 229   1        // master/slave selection
 230   1        SPI0CFG = clockMode | (isMasterMode ? SPI0CFG_MSTEN__MASTER_ENABLED
 231   1                                            : SPI0CFG_MSTEN__MASTER_DISABLED);
 232   1      
 233   1        // Set up the NSS mode bits depending on whether 3-wire or 4-wire
 234   1        // is used, and whether master or slave mode
C51 COMPILER V9.60.0.0   SPI_0                                                             11/11/2022 12:14:21 PAGE 5   

 235   1        if (is4wire)
 236   1        {
 237   2          SPI0CN0_NSSMD0 = 1;
 238   2          SPI0CN0_NSSMD1 = isMasterMode ? 1 : 0;
 239   2        }
 240   1        else
 241   1        {
 242   2          SPI0CN0_NSSMD0 = 0;
 243   2          SPI0CN0_NSSMD1 = 0;
 244   2        }
 245   1      
 246   1        // clear all the interrupt bits and enable the SPI
 247   1        SPI0CN0 &= ~0xF0;
 248   1        SPI0CN0_SPIEN = 1;
 249   1      }
 250          
 251          // ----------------------------------------------------------------------------
 252          // Set the clock divider used to determine SPI clock rate
 253          // ----------------------------------------------------------------------------
 254          void SPI0_setClockDivider(uint16_t divider)
 255          {
 256   1        // constrain input in case user passes a bad value
 257   1        if (divider > 512)
 258   1        {
 259   2          divider = 512;
 260   2        }
 261   1        if (divider < 2)
 262   1        {
 263   2          divider = 2;
 264   2        }
 265   1        // make even value
 266   1        divider &= ~1;
 267   1      
 268   1        // Transform the divider to the form needed by SFR.
 269   1        // See equation in the data sheet for more information
 270   1        divider /= 2;
 271   1        divider -= 1;
 272   1      
 273   1        // disable SPI before configuring, then update the value
 274   1        SPI0CN0_SPIEN = 0;
 275   1        SPI0CKR = (uint8_t)divider;
 276   1        SPI0CN0_SPIEN = 1;
 277   1      }
 278          
 279          #if EFM8PDL_SPI0_USE_BUFFER == 1
              
              // flag to indicate that RX buffer should be used for buffered transfers
              static bool useRx = false;
              
              // flag to indicate that TX buffer should be used for buffered transfers
              static bool useTx = false;
              
              static uint8_t rxCountRemaining = 0;
              static uint8_t txCountRemaining = 0;
              static uint8_t bytesRemaining = 0;
              static SI_VARIABLE_SEGMENT_POINTER(pTxBuf, uint8_t, EFM8PDL_SPI0_TX_SEGTYPE) = NULL;
              static SI_VARIABLE_SEGMENT_POINTER(pRxBuf, uint8_t, EFM8PDL_SPI0_RX_SEGTYPE) = NULL;
              
              // ----------------------------------------------------------------------------
              // Set up an interrupt driven SPI transfer.
              // ----------------------------------------------------------------------------
              void
              SPI0_transfer(SI_VARIABLE_SEGMENT_POINTER(pTxBuffer, uint8_t,
C51 COMPILER V9.60.0.0   SPI_0                                                             11/11/2022 12:14:21 PAGE 6   

                                                        EFM8PDL_SPI0_TX_SEGTYPE),
                            SI_VARIABLE_SEGMENT_POINTER(pRxBuffer, uint8_t,
                                                        EFM8PDL_SPI0_RX_SEGTYPE),
                            SPI0_TransferDirection_t dir,
                            uint8_t xferCount)
              {
                rxCountRemaining = xferCount;
                txCountRemaining = xferCount;
                bytesRemaining = xferCount;
                pTxBuf = pTxBuffer;
                pRxBuf = pRxBuffer;
                useRx = dir & SPI0_TRANSFER_RX;
                useTx = dir & SPI0_TRANSFER_TX;
              
                // Check to see if run-time mode variables have been set up
                if (!initIsValid)
                {
                  SPI0_internalInit();
                }
              
                // Flush the RX buffer in case something is in there
                {
                  uint8_t dummy = SPI0DAT;
                }
              
                // Clear all the interrupt flags
                SPI0CN0 &= ~0xF0;
              
                // assert NSS (if used)
                if (modeIsMaster && useNss)
                {
                  SPI0CN0_NSSMD0 = 0;
                }
              
              #if EFM8PDL_SPI0_USE_PIPELINE == 0
                // Write the first byte to get the transfer started
                if (SPI0CN0_TXBMT && txCountRemaining)
                {
                  // If user provided tx data, then use that
                  if (useTx)
                  {
                    SPI0DAT = *pTxBuf;
                    ++pTxBuf;
                  }
              
                  // Otherwise no tx data, so just stuff zeroes
                  else
                  {
                    SPI0DAT = 0;
                  }
                  --txCountRemaining;
                }
              #else
                // Stuff as many bytes as we can in the tx buffer to start.
                while (SPI0CN0_TXBMT && txCountRemaining)
                {
                  // If user provided tx data, then use that
                  if (useTx)
                  {
                    SPI0DAT = *pTxBuf;
                    ++pTxBuf;
                  }
              
C51 COMPILER V9.60.0.0   SPI_0                                                             11/11/2022 12:14:21 PAGE 7   

                  // Otherwise no tx data, so just stuff zeroes
                  else
                  {
                    SPI0DAT = 0;
                  }
                  --txCountRemaining;
                }
              #endif
              
                // At this point SPI should be running and the rest will be handled
                // in the interrupt service routine
              }
              
              // ----------------------------------------------------------------------------
              // Stop a running SPI transfer.
              // ----------------------------------------------------------------------------
              void SPI0_abortTransfer(void)
              {
                // Resetting the counters will cause the ISR to ignore any remaining
                // SPI interrupts.
                txCountRemaining = 0;
                rxCountRemaining = 0;
                useTx = false;
                useRx = false;
                pTxBuf = NULL;
                pRxBuf = NULL;
              
                // drop the chip select if used
                if (modeIsMaster && useNss)
                {
                  SPI0CN0_NSSMD0 = 1;
                }
              }
              
              // ----------------------------------------------------------------------------
              // Get the number of bytes remaining in the transfer.  This will really
              // be the number of RX bytes.
              // ----------------------------------------------------------------------------
              uint8_t SPI0_bytesRemaining(void)
              {
                return bytesRemaining;
              }
              
              // ----------------------------------------------------------------------------
              // Handler for interrupt driven SPI data transfers.
              // ----------------------------------------------------------------------------
              SI_INTERRUPT(SPI0_ISR, SPI0_IRQn)
              {
                uint8_t intFlags;
              
                // Get the interrupt flags and then clear any that are pending
                intFlags = SPI0CN0 & 0xF0;
                SPI0CN0 = (SPI0CN0 & (~intFlags | 0x0F));
              
                // Handle completion of one frame (byte) of data transferred.
                // This means we are ready to read a received byte, and write
                // the next TX byte.
                if (intFlags & SPI0_INT_IF)
                {
                  // Read bytes as long as the read count is non-zero
                  if (rxCountRemaining)
                  {
                    // If the user provided an RX buffer then read a byte into that.
C51 COMPILER V9.60.0.0   SPI_0                                                             11/11/2022 12:14:21 PAGE 8   

                    if (useRx)
                    {
                      *pRxBuf = SPI0DAT;
                      ++pRxBuf;
                    }
              
                    // Else, user does not care about RX data so do a dummy read.
                    else
                    {
                      uint8_t dummy = SPI0DAT;
                    }
                    --rxCountRemaining;
              
                    // If we get to zero remaining, it means that all the
                    // bytes have been transferred.
                    if (rxCountRemaining == 0)
                    {
                      // deassert NSS (if used)
                      if (modeIsMaster && useNss)
                      {
                        SPI0CN0_NSSMD0 = 1;
                      }
                      // Tell user that the transfer is complete.
                      SPI0_transferCompleteCb();
                    }
              
                    // If there are more RX bytes to receive, then remember the
                    // current count to be used by _bytesRemaining()
                    else
                    {
                      bytesRemaining = rxCountRemaining;
                    }
                  }
              
                  // Write bytes if there are more TX bytes to send and the
                  // TX buffer is not full
                  if (txCountRemaining && SPI0CN0_TXBMT)
                  {
                    // If user provided a TX buffer then write the next byte
                    if (useTx)
                    {
                      SPI0DAT = *pTxBuf;
                      ++pTxBuf;
                    }
              
                    // Otherwise user did not provide a buffer so just write a zero.
                    else
                    {
                      SPI0DAT = 0;
                    }
                    --txCountRemaining;
                  }
                }
              
              #if EFM8PDL_SPI0_USE_ERR_CALLBACK == 1
                // Check for errors and notify user
                if (intFlags & (SPI0_MODF_IF | SPI0_RXOVR_IF))
                {
                  // Note, the RXOVRN bit only happens in slave mode, and the MODF
                  // bit is not very likely, so in master mode this block will
                  // probably not ever be used.
                  SPI0_transferErrorCb(intFlags & (SPI0_MODF_IF | SPI0_RXOVR_IF));
                }
C51 COMPILER V9.60.0.0   SPI_0                                                             11/11/2022 12:14:21 PAGE 9   

              #endif // EFM8PDL_SPI0_USE_ERR_CALLBACK
              }
              
              #endif // EFM8PDL_SPI0_USE_BUFFER
 491          
 492          /** @} (end spi_0_group) */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    263    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3       5
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
