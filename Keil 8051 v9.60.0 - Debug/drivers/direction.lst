C51 COMPILER V9.60.0.0   DIRECTION                                                         11/17/2022 14:51:57 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE DIRECTION
OBJECT MODULE PLACED IN .\drivers/direction.OBJ
COMPILER INVOKED BY: Z:\Applications\Simplicity Studio.app\Contents\Eclipse\developer\toolchains\keil_8051\9.60\BIN\C51.
                    -exe /Users/paul_leveque/Documents/10_Projets/EFM8BB1_PCA_Lib_8bitCenterPWM/drivers/direction.c OMF2 SMALL DEBUG OBJECTEX
                    -TEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(/Use
                    -rs/paul_leveque/Documents/10_Projets/EFM8BB1_PCA_Lib_8bitCenterPWM/inc;/Users/paul_leveque/Documents/10_Projets/EFM8BB1_
                    -PCA_Lib_8bitCenterPWM/inc/config;/Users/paul_leveque/Documents/10_Projets/EFM8BB1_PCA_Lib_8bitCenterPWM/drivers;/Applica
                    -tions/Simplicity Studio.app/Contents/Eclipse/developer/sdks/8051/v4.2.4//Lib/efm8_assert;/Applications/Simplicity Studio
                    -.app/Contents/Eclipse/developer/sdks/8051/v4.2.4//Device/shared/si8051Base;/Applications/Simplicity Studio.app/Contents/
                    -Eclipse/developer/sdks/8051/v4.2.4//Device/EFM8BB1/inc;/Applications/Simplicity Studio.app/Contents/Eclipse/developer/sd
                    -ks/8051/v4.2.4//kits/common/bsp;/Applications/Simplicity Studio.app/Contents/Eclipse/developer/sdks/8051/v4.2.4//kits/EF
                    -M8BB1_LCK/config;/Applications/Simplicity Studio.app/Contents/Eclipse/developer/sdks/8051/v4.2.4//Device/EFM8BB1/periphe
                    -ral_driver/inc) PRINT(.\drivers/direction.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\drivers/direction.OBJ)

line level    source

   1          /*
   2           * direction.c
   3           *
   4           *  Created on: 10 nov. 2022
   5           *      Author: paul_leveque
   6           */
   7          
   8          #include "direction.h"
   9          
  10          // Permet d'aller dans la direction voulue :
  11          // void go_direction(tank_direction maDirection);
  12          
  13          void init_portsIn(void){
  14   1        P1MDOUT |= P1MDOUT_B0__PUSH_PULL| P1MDOUT_B1__PUSH_PULL | P1MDOUT_B2__PUSH_PULL;
  15   1           // | P1MDOUT_B3__PUSH_PULL;
  16   1        // Set Pins P1.0 to P1.3 as Output for controlling IN 1,2,3,4 ;
  17   1      
  18   1        // Initialise UART_0
  19   1      }
  20          
  21          
  22          // Permet d'avancer a une vitesse donnée (valeur a mettre dans le PWM)
  23          void go_forward(uint8_t speed){
  24   1        // TODO Ajouter le changement de valeur des ports
  25   1        // P1 |=   0x0A;   // 1010
  26   1        // P1 &=  ~0x05;   // 0101
  27   1      
  28   1        if ((PCA0CPM0 & PCA0CPM0_ECOM__BMASK) == PCA0CPM0_ECOM__DISABLED)
  29   1        {
  30   2          PCA0CPM0 |= PCA0CPM0_ECOM__BMASK;   // Set ECOM0 if it is '0'
  31   2        }
  32   1      
  33   1        if ((PCA0CPM1 & PCA0CPM1_ECOM__BMASK) == PCA0CPM1_ECOM__DISABLED)
  34   1        {
  35   2          PCA0CPM1 |= PCA0CPM1_ECOM__BMASK;   // Set ECOM1 if it is '0'
  36   2        }
  37   1      
  38   1        PCA0_writeChannel(PCA0_CHAN0, speed << 8);
  39   1      
  40   1        PCA0_writeChannel(PCA0_CHAN1, speed << 8);
  41   1      
  42   1        // + set pins IN(1:4) low or high accordingly
  43   1      
  44   1      }
  45          
  46          // Permet de reculer a une vitesse donnée (valeur a mettre dans le PWM)
C51 COMPILER V9.60.0.0   DIRECTION                                                         11/17/2022 14:51:57 PAGE 2   

  47          void go_backward(uint8_t speed){
  48   1      
  49   1        P1 |=   0x05;   // 0101
  50   1        P1 &=  ~0x0A;   // 1010
  51   1      
  52   1        if ((PCA0CPM0 & PCA0CPM0_ECOM__BMASK) == PCA0CPM0_ECOM__DISABLED)
  53   1        {
  54   2          PCA0CPM0 |= PCA0CPM0_ECOM__BMASK;   // Set ECOM0 if it is '0'
  55   2        }
  56   1        else {
  57   2          PCA0_writeChannel(PCA0_CHAN0, speed << 8);
  58   2        }
  59   1      
  60   1        if ((PCA0CPM1 & PCA0CPM1_ECOM__BMASK) == PCA0CPM1_ECOM__DISABLED)
  61   1        {
  62   2          PCA0CPM1 |= PCA0CPM1_ECOM__BMASK;   // Set ECOM1 if it is '0'
  63   2        }
  64   1        else {
  65   2          PCA0_writeChannel(PCA0_CHAN1, speed << 8);
  66   2        }
  67   1        // + set pins IN(1:4) low or high accordingly
  68   1      
  69   1      }
  70          
  71          // Permet de tourner a droite a une vitesse donnée (valeur a mettre dans le PWM)
  72          void turn_right(uint8_t speed){
  73   1        P1 |=   0x06;   // 0110
  74   1        P1 &=  ~0x09;   // 1001
  75   1      
  76   1        if ((PCA0CPM0 & PCA0CPM0_ECOM__BMASK) == PCA0CPM0_ECOM__DISABLED)
  77   1        {
  78   2          PCA0CPM0 |= PCA0CPM0_ECOM__BMASK;   // Set ECOM0 if it is '0'
  79   2        }
  80   1        else {
  81   2          PCA0_writeChannel(PCA0_CHAN0, speed << 8);
  82   2        }
  83   1      
  84   1        if ((PCA0CPM1 & PCA0CPM1_ECOM__BMASK) == PCA0CPM1_ECOM__DISABLED)
  85   1        {
  86   2          PCA0CPM1 |= PCA0CPM1_ECOM__BMASK;   // Set ECOM1 if it is '0'
  87   2        }
  88   1        else {
  89   2          PCA0_writeChannel(PCA0_CHAN1, speed << 8);
  90   2        }
  91   1        // + set pins IN(1:4) low or high accordingly
  92   1      
  93   1      }
  94          
  95          // Permet de tourner a gauche a une vitesse donnée (valeur a mettre dans le PWM)
  96          void turn_left(uint8_t speed){
  97   1        P1 |=   0x09;   // 1001
  98   1        P1 &=  ~0x06;   // 0110
  99   1      
 100   1        if ((PCA0CPM0 & PCA0CPM0_ECOM__BMASK) == PCA0CPM0_ECOM__DISABLED)
 101   1        {
 102   2          PCA0CPM0 |= PCA0CPM0_ECOM__BMASK;   // Set ECOM0 if it is '0'
 103   2        }
 104   1        else {
 105   2          PCA0_writeChannel(PCA0_CHAN0, speed << 8);
 106   2        }
 107   1      
 108   1        if ((PCA0CPM1 & PCA0CPM1_ECOM__BMASK) == PCA0CPM1_ECOM__DISABLED)
 109   1        {
C51 COMPILER V9.60.0.0   DIRECTION                                                         11/17/2022 14:51:57 PAGE 3   

 110   2          PCA0CPM1 |= PCA0CPM1_ECOM__BMASK;   // Set ECOM1 if it is '0'
 111   2        }
 112   1        else {
 113   2          PCA0_writeChannel(PCA0_CHAN1, speed << 8);
 114   2        }
 115   1        // + set pins IN(1:4) low or high accordingly
 116   1      
 117   1      }
 118          
 119          // permet d'arreter les moteurs
 120          void stop(){
 121   1        PCA0CPM0 &= ~PCA0CPM0_ECOM__BMASK;  // Clear ECOM0
 122   1        PCA0CPM1 &= ~PCA0CPM1_ECOM__BMASK;  // Clear ECOM0
 123   1        // + set pins IN(1:4) low or high accordingly
 124   1      
 125   1      }
 126          
 127          void test_moteur(void){
 128   1        uint16_t delay_count;               // Used to implement a delay
 129   1        uint8_t duty_direction0 = 1;        // Module 0: 0 = Decrease; 1 = Increase
 130   1        bool duty_direction1 = 0;           // Module 1: 0 = Increase; 1 = Decrease
 131   1      
 132   1        uint8_t duty_cycle0 = 0x80;
 133   1        uint8_t duty_cycle1 = 0xFF;
 134   1        for (delay_count = 30000; delay_count > 0; delay_count--);
 135   1      
 136   1        if (duty_direction1 == 1 ){
 137   2            duty_cycle0 = duty_cycle0 + duty_direction0;
 138   2            go_backward(duty_cycle0);
 139   2      
 140   2            if (duty_cycle0 == 0x2F) {
 141   3                duty_direction0 = -1;
 142   3                duty_direction1 = 0;
 143   3            }
 144   2            if (duty_cycle0 == 0x00) {
 145   3                duty_direction0 = 1;
 146   3            }
 147   2        }
 148   1        else {
 149   2            duty_cycle0 = duty_cycle0 + duty_direction0;
 150   2            go_forward(duty_cycle0);
 151   2      
 152   2            if (duty_cycle0 == 0x2F) {
 153   3                duty_direction0 = -1;
 154   3                duty_direction1 = 1;
 155   3            }
 156   2            if (duty_cycle0 == 0x00) {
 157   3                duty_direction0 = 1;
 158   3            }
 159   2        }
 160   1      }
 161          /*
 162          void analyseCommandFromRaspberry(void){
 163            switch (dataFromRaspberry.bufferedData[0]) {
 164              case FORWARD_PROTOCOL_LETTER:
 165                dataFromRaspberry.orderedDirection = forward;
 166                dataFromRaspberry.speed = dataFromRaspberry.bufferedData[1];
 167                break;
 168              case BACKWARD_PROTOCOL_LETTER:
 169                dataFromRaspberry.orderedDirection = backward;
 170                dataFromRaspberry.speed = dataFromRaspberry.bufferedData[1];
 171                break;
 172              case TURN_LEFT_PROTOCOL_LETTER:
C51 COMPILER V9.60.0.0   DIRECTION                                                         11/17/2022 14:51:57 PAGE 4   

 173                dataFromRaspberry.orderedDirection = turnLeft;
 174                dataFromRaspberry.speed = dataFromRaspberry.bufferedData[1];
 175                break;
 176              case TURN_RIGHT_PROTOCOL_LETTER:
 177                dataFromRaspberry.orderedDirection = turnRight;
 178                dataFromRaspberry.speed = dataFromRaspberry.bufferedData[1];
 179                break;
 180              default:
 181                break;
 182            }
 183          }
 184          */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    290    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       7
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
